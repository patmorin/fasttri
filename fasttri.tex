\documentclass[kpfonts]{patmorin}
\listfiles
\usepackage{pat}
\usepackage{paralist}
\usepackage{dsfont}  % for \mathds{A}
\usepackage[utf8]{inputenc}

\usepackage{graphicx}
\usepackage[noend]{algorithmic}

\usepackage{xcolor}
\definecolor{light-gray}{gray}{0.95}

\usepackage[normalem]{ulem}
\usepackage{cancel}
\usepackage{enumitem}


\newcommand{\snote}[1]{\fcolorbox{red}{yellow}{#1}}
\newcommand{\pnote}[1]{\ \newline\noindent\fcolorbox{red}{yellow}{\begin{minipage}{\textwidth}#1\end{minipage}}}
\setlength{\parskip}{1ex}

\DeclareMathOperator{\A}{\mathds{A}}
\DeclareMathOperator{\sn}{sn}
\DeclareMathOperator{\qn}{qn}

\renewcommand{\SS}{\mathcal{S}}

\newcommand{\Oh}{\mathcal{O}}


%Piotreks overloads
\let\le\leqslant
\let\ge\geqslant
\let\leq\leqslant
\let\geq\geqslant
\let\nleq\nleqslant
\let\ngeq\ngeqslant
%%Piotrek end

\newcommand{\aref}[1]{(X\ref{a:#1})}
\newcommand{\alabel}[1]{\label{a:#1}}

\newcommand{\itemref}[1]{(\ref{#1})}

\title{\MakeUppercase{A Fast Algorithm for Layered $H$-Partitions of Planar Graphs}}
\author{
  Pat Morin%
    \thanks{School of Computer Science, Carleton University, Canada. This research was partially supported by NSERC.}
}
\date{}

\begin{document}
\begin{titlepage}
\maketitle

\begin{abstract}
  Dujmović et al (FOCS2019) recently proved that every planar graph $G$ is a subgraph of $H\boxtimes P$, where $\boxtimes$ denotes the strong graph product, $H$ is a graph of treewidth 8 and $P$ is a path.  This result has found numerous applications to linear graph layouts, graph colouring, and graph labelling.  The proof given by Dujmović et al is based on a similar decomposition of Pilipczuk and Siebertz (SODA2019) which is constructive and leads to an $O(n^2)$ time algorithm for finding $H$ and the mapping from $V(G)$ onto $V(H\boxtimes P)$.  In this note, we show that this algorithm can be made to run in $O(n\log^2 n)$ time.
\end{abstract}
\end{titlepage}
\pagenumbering{roman}
\tableofcontents

\newpage

\setcounter{page}{0}
\pagenumbering{arabic}
\section{Introduction}

\section{Preliminaries}

Our algorithm makes use of a data structure that preprocesses a rooted $n$-vertex tree $T$ whose edges are all initially uncoloured and supports the following operations:
\begin{enumerate}
  \item $\textsc{Colour}(e,c)$: Set the colour of an edge $e$ of $T$ to some value $c\in\{1,2,3\}$.
  \item $\textsc{FirstColour}(w)$: Return the colour of the first coloured edge on the path from node $w$ to the root of $T$, or return $\perp$ if no such edge exists.
\end{enumerate}

The proof of the following lemma uses fairly standard techniques from the field of data structures.

\begin{lem}
  There exists a data structure that, given an $n$-vertex rooted tree $T$, uses $O(n\log n)$ space, can be constructed in $O(n\log n)$ time, supports the operation $\textsc{FirstColour}(v)$ in $O(1)$ time and supports $m$ $\textsc{Colour}(e,c)$ operations in $O(n+m\log n)$ time.
\end{lem}

\begin{lem}
    If $n\le 1$, then the problem is trivial, so assume that $|T|\ge 2$.
    
    We decompose $T$ in a sequence $F_0,\ldots,F_r$ of forests, where $F_0:=T$ and, for each $i\in\{1,\ldots,r\}$, $F_i$ is a spanning subgraph of $F_{i-1}$ and each tree in $F_i$ has size at most $\lceil n/2^i\rceil$.  

    Decompose $T$ by removing a node $v$ that has at least $n/2$ $T$-descendants and each child of $v$ is the root of a subtree of size at most $n/2$. Removing all the edges between $v$ and its children creates a forest $F$ containing tree $T_0,\ldots,T_k$ where $T_0$ contains $v$ (and the root of $T$) and $T_i$ is rooted at a child of $v$, for each $i\in\{1,\ldots,k\}$.

    
    For each node $w$ of $T$ store the index $i_w\in\{0,\ldots,k\}$ of the tree $T_{i_w}$ that contains $w$.  Now, recursively preprocess the subtrees $T_0,\ldots,T_k$.  Finding the node $v$ takes $O(n)$ time, and the recursion leads to an overall running time of $O(n\log n)$.
    
    With this preprocessing done, the operations are implmented as follows:
    \begin{enumerate}
    \item $\textsc{Colour}(e,c)$. Let $e=xy$ where $x$ is the parent of $y$.  Then we store the colour $c$ with the node $y$.
    
    \item $\textsc{FirstColour}(w)$:  First check if $i_w=0$.  If so, $w$ is a node of $T_0$, so recursively call $\textsc{FirstColour}(v)$ and return the result.  Otherwise, $w$ is a node of $T_{i}$, for some $i:=i_w\in\{1,\ldots,k\}$.  
    \end{enumerate}
    
  
\end{lem}


\end{document}
